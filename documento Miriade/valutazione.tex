\section{Valutazione del prodotto finale}
\label{valutazione}
%Qui daremo una valutazione del risultato finale in ambito SW, HW e UX (software, hardware e user experience), esaltando i pregi e riportando gli eventuali difetti da correggere
Per la progettazione di questo prodotto sono stati previsti degli obiettivi da raggiungere per ottenere il miglior risultato finale possibile. Durante la realizzazione del progetto essi sono in parte mutati, sia perché lo studio delle possibilità offerte da Android ha portato a soluzioni differenti, sia perché sono sorti alcuni problemi, come la mancanza di tempo o la maggior difficoltà incontrata nell'implementazione di una determinata caratteristica. In questa sezione verrà analizzato il prodotto, e quindi i relativi pregi e difetti, esaminandolo dal punto di vista del software, dell'hardware e della user experience.
	\subsection{Software}
		L'applicazione è divisa in vari package, ognuno con uno scopo preciso:
		\begin{itemize}
			\item ‘‘viewcontroller’’ contiene tutte le activity che gestiscono le GUI;
			\item ‘‘pathprogress’’ include le classi che gestiscono l'interazione con il GPS, quella con il Bluetooth e la memorizzazione dei risultati del percorso durante il suo svolgimento;
			\item ‘‘data’’ contiene le classi del Model e quelle specifiche per la loro costruzione;
			\item ‘‘datamanager’’ include le classi con lo scopo di ottenere i dati richiesti dal server o dal database locale, a seconda della polizza di cache usata;
			\item ‘‘urlrequest’’ contiene le classi responsabili della costruzione e dell'invocazione delle chiamate al server.
		\end{itemize}
		In questo modo è possibile verificare e modificare facilmente ogni passaggio di un'operazione.
		‘‘urlrequest’’ e ‘‘datamanager’’ contengono una struttura simile: è presente una gerarchia, in cui la cima è rappresentata da una classe astratta che svolge o gestisce le operazioni principali. Nel caso dell'‘‘urlrequest’’ tale classe crea ed esegue la chiamata in base ai parametri ricevuti, invece in ‘‘datamanager’’ essa gestisce le operazioni da fare in base alla politica di cache. Le classi derivate semplicemente definiscono i parametri e le azioni specifiche dell'operazione da gestire. Infine è presente una classe che funziona come una specie di interfaccia con il resto dell'applicazione, che contiene un metodo statico per ogni richiesta prevista. In questo modo si limitano le possibilità di commettere errori, perché gli esiti di ogni operazione sono facilmente verificabili e le classi responsabili degli errori eventuali sono subito identificabili.
		Come pattern per la notifica degli esiti delle richieste sono stati usati principalmente i listener, più che altro per comodità.
		Per quanto riguarda il GPS sono stati usati i Google Play Services, i più semplici da usare e anche i più recenti. Per le richieste al server è stata usata la libreria ‘‘Volley’’, più che sufficiente per l'uso che ne dovevamo fare. Per il rilevamento dei beacon è stato usato il framework messo a disposizione da Kontakt, semplice da implementare ma limitato, come spiegato tra le \hyperref[sec:libreria_beacon]{idee per il miglioramento dell'applicazione}.
		%TODO: aggiungere eventuali note per la parte di viewcontroller, ad esempio sul discorso delle classi Serializable oppure sulla gestione delle view, per esempio quando il formato dello schermo cambia
	\subsection{Hardware}
		L'applicazione non ha molti limiti per quanto riguarda il lato hardware, in cambio però richiede l'utilizzo di parecchi servizi. Innanzitutto occorre una connessione ad Internet per poter effettuare le richieste al server, sebbene tali chiamate abbiano una dimensione di pochi kB, e quindi anche una connessione debole dovrebbe essere sufficiente. È necessario poi utilizzare il GPS per rilevare la posizione dell'utente, in modo da informarlo se si trova vicino ad un edificio abilitato o no, e per mostrare l'elenco delle strutture più vicine; per ottenere un risultato accettabile è necessario avere una precisione elevata, perché ad esempio in città una bassa precisione potrebbe portare ad una lista degli edifici inconsistente, peggiorando la user experience. Infine è necessario usare il Bluetooth per rilevare i beacon.
		Il consumo della batteria rilevato durante i test è nella norma, ovvero è maggiore quando si esegue l'applicazione ma non eccessivo. Per far risparmiare batteria si potrebbe consigliare di disattivare il Bluetooth dopo aver finito di giocare un percorso e il GPS dopo aver trovato il percorso da giocare, anche se l'energia risparmiata è abbastanza poca.
		Le versioni di Android supportate dall'applicazione sono la 5 e le successive, perché sono quelle che supportano sufficientemente bene la lettura dei beacon. Nei dispositivi che usano la versione 6 di Android o una successiva è necessario abilitare i servizi per ogni singola applicazione, purtroppo non siamo riusciti a cercare una soluzione a questo ostacolo, che rappresenta un problema per la user experience, dato che il servizio non funziona anche se risulta acceso.
		Il tempo impiegato per rilevare il beacon varia a seconda del dispositivo: dalle prove che abbiamo fatto i risultati ottenuti vanno da cellulari che impiegano un secondo ad altri che invece ne impiegano anche 6 o 7. L'esito quindi è sufficiente per poter giocare un percorso, sebbene in certi casi bisogna aumentare la potenza del beacon per evitare che l'utente ci passi davanti senza fare in tempo a rilevarlo, ad esempio quando la stazione è situata in una zona di passaggio come un corridoio. Probabilmente cambiando la frequenza e la durata delle pause tra una ricerca e l'altra si possono ottenere risultati migliori.
		%TODO: vedere se aggiungere qualcosa relativa al viewcontroller, ad esempio se c'è qualcosa da segnalare per quanto riguarda la dimensione degli schermi
	\subsection{User experience}
		L'applicazione è strutturata in modo semplice, in modo da permettere all'utente di cominciare subito a giocare un percorso se si trova in un luogo abilitato. La prima pagina mostrata permette di cercare gli edifici più vicini, da cui poi è appunto possibile cominciare un percorso. Ogni GUI, a parte quelle che appaiono quando si gioca un percorso, presentano un menù da cui è possibile accedere a tutte le funzioni offerte dall'applicazione, fra cui la registrazione di un nuovo account, il login, il logout, le informazioni sul prodotto e sugli sviluppatori, la modifica dei dati del profilo e la ricerca degli edifici.
		Per giocare i percorsi non è necessario che l'utente abbia eseguito il login, se non vuole farlo semplicemente non può salvare il risultato ottenuto; viene comunque proposto all'utente di fare il login o di registrarsi quando finisce un percorso, in modo da poterne salvare l'esito. 
		Ogni volta che è necessario usare un servizio viene controllato se è attivo, in caso negativo l'utente viene invitato ad attivarlo; se non lo abilita non può andare avanti.
		Il pulsante per tornare indietro viene disabilitato quando l'utente inizia il percorso, in modo da impedirgli di rispondere ad una domanda a cui ha già risposto.
		Se viene rilevato un errore esso viene opportunamente segnalato, mostrando un messaggio all'utente; è però un sistema senz'altro migliorabile, ad esempio per quanto riguarda la visibilità e il messaggio che viene mostrato.
		La semplicità e l'uso immediato dell'applicazione sono uno dei punti fondamentali per la user experience, ma è possibile ottenere dei risultati ancora migliori, ad esempio \hyperref[sec:gestione_errori]{migliorando la gestione degli errori}\, come appunto è già stato detto, o \hyperref[sec:tutorial]{aggiungendo un tutorial introduttivo da mostrare al primo utilizzo}.
		%TODO: vedere se aggiungere qualcosa sulle GUI