\newcommand{\utilizzo}{\item \textbf{Utilizzo nel progetto}}

\section{Design pattern utilizzati}
\label{pattern}
\subsection{Pattern architetturali}
	\subsubsection{Model View Presenter}
	
		\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.5]{img/mvp}  
			\caption{Struttura del pattern MVP}
		\end{figure}
		
		\begin{itemize}	
			\item \textbf{Descrizione} \\ Model View Presenter è un design pattern architetturale simile al Model View Controller nel quale il presenter è posizionato tra model e view. Permette di dividere l'architettura del sistema che si intende sviluppare in tre blocchi:
			\begin{itemize}
				\item \textbf{il model} che contiene le classi con i metodi di accesso ai dati;
				\item \textbf{la view}, completamente pasiva, contiene le classi che permettono all'utente di visualizzare i dati e segnala tramite gli eventi le interazioni dell'utente;
				\item \textbf{il presenter} che si occupa di fare da tramite tra vista e modello, ovvero riceve i comandi dell'utente attraverso la vista e va a cambiare lo stato del modello di conseguenza, successivamente aggiorna la vista.				
			\end{itemize}
			
			\item \textbf{Vantaggi} \\
			Questo pattern architetturale permette il riuso del codice in quanto molte parti di lavoro sono indipendenti. Ad esempio il modello creato potrà essere utilizzato con diverse viste. \\ Grazie all'indipendenza di alcune parti è semplice dividere il lavoro tra più componenti di un team e sarà quindi più facile anche la manutenzione.
			\utilizzo \\
			Nel nostro progetto il pattern MVP è usato nella parte client dell'architettura, nello specifico il model è rappresentato dalle classi del database locale, ciè quelle del package \textbf{Data}, le view sono rappresentate dai \textbf{file XML} di Android che vengono utilizzati per la gestione del layout mentre il presenter è costituito dalle classi \textbf{activity} e dalle classi all'interno del package \textbf{Datamanager}.
		\end{itemize}
		
		\newpage
		
\subsection{Pattern creazionali}
	\subsubsection{Abstract Factory}
	
	\begin{figure}[!h]
		\centering
		\includegraphics[scale=0.2]{img/abstract_factory}  
		\caption{Struttura del pattern Abstract Factory}
	\end{figure}
	
		\begin{itemize}
			\item \textbf{Descrizione}\\ 
			Il design pattern Abstract Factory fornisce un'interfaccia per creare famiglie di prodotti senza specificare classi concrete. Ogni famiglia di prodotti ha una classe base astratta da cui derivano delle classi concrete. Queste classi concrete sono istanziate dalle classi concrete della factory corrispondenti.
			% immagine di esempio
			
			\item \textbf{Vantaggi}\\ 
			Questo design pattern offre vantaggi quando si vogliono modellare famiglie di prodotti che potranno essere ampliate nel futuro. Le modifiche necessarie ad aggiungere nuovi elementi alle famiglie saranno essenzialmente due, aggiungere una classe in ogni famiglia di prodotti ed un solo metodo nella factory.
			\utilizzo \\ 
			Nel nostro progetto abbiamo utilizzato questo design pattern per modellare i tipi di quiz che vengono proposti agli utenti. Abbiamo infatti deciso di utilizzare solo due famiglie di quiz, quindi vi è la necessità di avere modo in futuro di ampliare le tipologie di quiz disponibili in modo semplice ed efficace.
			
			\begin{figure}[!h]
				\centering
				\includegraphics[scale=0.4]{img/our_abstract_factory}  
				\caption{Utilizzo di Abstract Factory nel progetto}
			\end{figure}
			
		\end{itemize}
	 \newpage
	 
	\subsubsection{Singleton}
		\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.4]{img/singleton}  
			\caption{Struttura del pattern Singleton}
		\end{figure}
		
		\begin{itemize}
			\item \textbf{Descrizione}\\ 
			 Assicura l'esistenza di un'unica istanza di una classe e permette di avere un punto di accesso globale a questa.
			 Per rendere possibile ciò si mette il costruttore protetto o privato e si crea un metodo statico, chiamato factory, che fornisce l’accesso all'unica copia dell’oggetto (contiene un puntatore all’unica istanza). \\
			 È stata valutata come alternativa la \gl{Dependency Injection}, un altro \gl{design pattern}. Essa prevede la costruzione di una classe le cui dipendenze vengono ricevute dall'esterno. Di base non ha le stesse proprietà del \gl{Singleton}, ma può acquisirle tramite degli appositi accorgimenti, come l'utilizzo di una \gl{Factory}\ per la costruzione delle dipendenze. Questo \gl{design pattern}\ ha come vantaggi una maggiore facilità nel testare la classe, perché si possono creare delle dipendenze false da inviare alla \gl{Dependency Injection}, e la separazione tra il comportamento della componente dalla risoluzione delle sue dipendenze; al contrario il \gl{Singleton}\ rende privato tutto quello che le occorre per costruire la classe, mantenendolo quindi al proprio interno. Lo svantaggio invece risiede nella maggiore complessità di costruzione, in quanto la \gl{Dependency Injection}\ richiede l'utilizzo di almeno due classi con una forte dipendenza tra loro, anziché un'unica classe come il \gl{Singleton}. Quest'ultimo è stato scelto alla fine perché nel nostro caso le dipendenze sono poche e il risultato prodotto è facilmente verificabile tramite degli appositi metodi, perciò lo svantaggio della \gl{Dependency Injection}\ peserebbe molto di più rispetto a vantaggi.
			 \item \textbf{Vantaggi}\\ 
			 Se, al contrario di quanto avviene utilizzando Singleton, venisse reso visibile il costruttore della classe non si potrebbe garantire che esista un solo esemplare della classe. Un altro modo di procedere potrebbe essere quello di dichiarare una variabile globale, ma in questo modo si ``ruberebbe'' un nome al namespace globale.
			 Sigleton permette inoltre di dichiarare sottoclassi.			 
			 \utilizzo \\ 
			 Nel nostro progetto abbiamo creato un singleton per ``LoginManager'' che contiene i dati relativi a i dati di login dell'utente che sta utilizzando l'applicazione.
			 
			 	\begin{figure}[!h]
			 		\centering
			 		\includegraphics[scale=0.4]{img/package/png/client--loginmanager}  
			 		\caption{Utilizzo di Abstract Factory nel progetto}
			 	\end{figure}
			 
		\end{itemize}
		
		
		
